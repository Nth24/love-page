<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>20/10 ‚Äî C·∫£m ∆°n em</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  #canvas{display:block;width:100%;height:100%;}
  .download-note{position:fixed;right:12px;top:12px;z-index:999;color:#fff;background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:8px;font-size:13px}
  #credits{position:fixed;left:12px;top:12px;z-index:999;color:#fff;background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:8px;font-size:13px}
  /* simple pause/play button */
  #controls{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:999;color:#fff}
  #controls button{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);color:#fff;padding:8px 12px;border-radius:20px;cursor:pointer}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="credits">M·ªü b·∫±ng tr√¨nh duy·ªát ‚Üí T·ªët nh·∫•t l√† Chrome / Edge / Firefox</div>
<div class="download-note">File: index.html ‚Äî T·∫£i v·ªÅ r·ªìi upload l√™n Netlify ho·∫∑c m·ªü tr·ª±c ti·∫øp</div>

<script>
// ---------- Config ----------
const TEXT = "C·∫£m ∆°n em ƒë·∫øn b√™n anh. Ch√∫c em 20/10 h·∫°nh ph√∫c üíñ  ";
const HEART_COLOR1 = {r:255,g:90,b:140}; // h·ªìng ƒë·ªè
const HEART_COLOR2 = {r:255,g:40,b:90};
const STAR_COUNT = 120;
const PARTICLE_COUNT = 900; // heart particles
const SMALL_HEART_RATE = 0.02; // chance each frame to spawn small heart
const FIREWORK_RATE = 0.005; // chance to spawn firework
// ----------------------------

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: true });
let W=canvas.width=innerWidth, H=canvas.height=innerHeight;
window.addEventListener('resize', ()=>{ W=canvas.width=innerWidth; H=canvas.height=innerHeight; init(); });

function rand(a,b){return a + Math.random()*(b-a);}
function lerp(a,b,t){return a + (b-a)*t;}
function hslToRgb(h,s,l){
  // h in [0,360], s,l in [0,1]
  s=Math.max(0,Math.min(1,s)); l=Math.max(0,Math.min(1,l));
  const c=(1-Math.abs(2*l-1))*s;
  const x=c*(1-Math.abs((h/60)%2-1));
  const m=l-c/2;
  let r=0,g=0,b=0;
  if(h<60){r=c;g=x;b=0;}
  else if(h<120){r=x;g=c;b=0;}
  else if(h<180){r=0;g=c;b=x;}
  else if(h<240){r=0;g=x;b=c;}
  else if(h<300){r=x;g=0;b=c;}
  else {r=c;g=0;b=x;}
  return {r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255)};
}

// Stars
let stars = [];
function makeStars(){
  stars = [];
  for(let i=0;i<STAR_COUNT;i++){
    stars.push({
      x: Math.random()*W,
      y: Math.random()*H*0.6,
      r: Math.random()*1.6+0.4,
      a: Math.random()*0.8+0.2,
      tw: rand(1.5,4),
      off: Math.random()*10
    });
  }
}

// Heart shaped particles (parametric heart curve)
function heartPoint(t){
  // classic heart curve: x = 16 sin^3 t, y = 13 cos t - 5 cos 2t -2 cos 3t - cos 4t
  const x = 16*Math.pow(Math.sin(t),3);
  const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  return {x,y};
}

let particles = [];
function makeHeartParticles(){
  particles = [];
  const cx = W/2, cy = H*0.45;
  const scale = Math.min(W,H)/50;
  for(let i=0;i<PARTICLE_COUNT;i++){
    const t = rand(0,Math.PI*2);
    const hp = heartPoint(t);
    // add jitter so particles fill the heart
    const jitter = rand(-0.8,0.8);
    const px = cx + hp.x*scale + jitter*scale;
    const py = cy - hp.y*scale + jitter*scale*0.5;
    const size = rand(0.8,2.5);
    const life = rand(200,400);
    const color = Math.random()<0.6 ? HEART_COLOR1 : HEART_COLOR2;
    particles.push({x:px,y:py,ox:px,oy:py, vx:0,vy:0, size, life, age:rand(0,life), color, float:rand(-0.3,0.3)});
  }
}

// Small floating hearts that rise from bottom
let smallHearts = [];
function spawnSmallHeart(){
  const x = W/2 + rand(-140,140);
  const y = H*0.68 + rand(-10,30);
  const vx = rand(-0.4,0.4);
  const vy = rand(-0.8,-1.8);
  const s = rand(6,14);
  const rot = rand(0,Math.PI*2);
  const life = rand(140,260);
  smallHearts.push({x,y,vx,vy,s,rot,age:0,life,alpha:0.9});
}

// Fireworks as bursts near heart
let fireworks = [];
function spawnFirework(){
  const cx=W/2 + rand(-120,120);
  const cy=H*0.42 + rand(-80,80);
  const count = rand(18,32)|0;
  const parts = [];
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const sp = rand(1.6,4.2);
    const vx = Math.cos(ang)*sp;
    const vy = Math.sin(ang)*sp;
    const size = rand(1.2,3.5);
    const color = Math.random()<0.5 ? HEART_COLOR1 : HEART_COLOR2;
    parts.push({x:cx,y:cy,vx,vy,age:0,life:rand(60,120),size,color});
  }
  fireworks.push({parts,age:0});
}

// Orbiting text rendered on an inclined ellipse
let txtAngle = 0;

function drawTextOnEllipse(){
  const text = TEXT;
  // ellipse params (tilted)
  const a = Math.min(W,H)/3.6; // major radius
  const b = a*0.55; // minor radius to simulate tilt
  const cx=W/2, cy=H*0.75;
  const tilt = -Math.PI*0.18; // tilt angle for the ellipse
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(tilt);
  // calculate total circumference approx for spacing
  ctx.font = "20px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const txt = (text + "   ").repeat(6);
  const len = txt.length;
  // draw each character positioned by angle
  for(let i=0;i<len;i++){
    const frac = (i/len + (txtAngle/(Math.PI*2)))%1;
    const ang = frac* Math.PI*2;
    // point on ellipse
    const x = a*Math.cos(ang);
    const y = b*Math.sin(ang);
    // rotate char to face along tangent
    // derivative: dx/dt = -a sin t, dy/dt = b cos t => angle = atan2(dy,dx)
    const dx = -a*Math.sin(ang);
    const dy = b*Math.cos(ang);
    const charAngle = Math.atan2(dy,dx);
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(charAngle + Math.PI/2);
    // shimmer color gradient
    const grade = ctx.createLinearGradient(-10,-10,10,10);
    grade.addColorStop(0,"rgba(255,220,235,0.95)");
    grade.addColorStop(1,"rgba(255,120,170,0.95)");
    ctx.fillStyle = grade;
    ctx.fillText(txt[i],0,0);
    ctx.restore();
  }
  ctx.restore();
}

// draw big glowing heart overlay highlight
function drawBigHeartGlow(){
  const cx=W/2, cy=H*0.45;
  const grad = ctx.createRadialGradient(cx,cy,10,cx,cy,Math.min(W,H)/2.2);
  grad.addColorStop(0,'rgba(255,150,190,0.20)');
  grad.addColorStop(0.5,'rgba(255,80,140,0.08)');
  grad.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);
}

// utility to draw a heart shape for small hearts
function drawHeartShape(x,y,s,alpha){
  ctx.save();
  ctx.translate(x,y);
  ctx.scale(s/20,s/20);
  ctx.rotate(-0.25);
  ctx.beginPath();
  ctx.moveTo(0,-6);
  ctx.bezierCurveTo(12,-28,34,-10,0,28);
  ctx.bezierCurveTo(-34,-10,-12,-28,0,-6);
  ctx.closePath();
  ctx.fillStyle = `rgba(255,90,140,${alpha})`;
  ctx.fill();
  ctx.restore();
}

// initial setup
function init(){
  makeStars();
  makeHeartParticles();
  smallHearts = [];
  fireworks = [];
}
init();

// animation loop
let t=0;
function step(){
  t+=1;
  // background
  ctx.clearRect(0,0,W,H);
  // subtle gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#000006');
  g.addColorStop(1,'#000000');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // draw stars
  for(let i=0;i<stars.length;i++){
    const s = stars[i];
    const a = s.a + Math.sin((t/ s.tw)+s.off)*0.25;
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${a})`;
    ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctx.fill();
  }

  // draw particle heart (particles slowly float outward and twinkle)
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    // gentle float movement from original position
    const dx = p.ox - p.x;
    const dy = p.oy - p.y;
    // small turbulent motion
    p.vx += (Math.random()-0.5)*0.06 + dx*0.001;
    p.vy += (Math.random()-0.5)*0.06 + dy*0.001 + p.float*0.002;
    p.x += p.vx;
    p.y += p.vy;
    p.age++;
    // pulsate size
    const s = p.size * (1 + Math.sin((p.age/8)+p.float)*0.35);
    const alpha = 0.6 + 0.4*Math.sin(p.age*0.05 + p.float*5);
    ctx.beginPath();
    const c = p.color;
    ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${alpha})`;
    ctx.arc(p.x,p.y,s,0,Math.PI*2);
    ctx.fill();
  }

  // occasional spawn of small hearts
  if(Math.random() < SMALL_HEART_RATE){
    spawnSmallHeart();
  }
  // update small hearts
  for(let i=smallHearts.length-1;i>=0;i--){
    const h = smallHearts[i];
    h.x += h.vx + Math.sin((h.age+h.s)/10)*0.2;
    h.y += h.vy - Math.sin(h.age/12)*0.08;
    h.vy *= 0.998;
    h.age++;
    h.rot += 0.02;
    h.alpha = Math.max(0, 0.9*(1 - h.age/h.life));
    drawHeartShape(h.x, h.y, h.s, h.alpha);
    if(h.age > h.life || h.y < -30) smallHearts.splice(i,1);
  }

  // occasional fireworks
  if(Math.random() < FIREWORK_RATE){
    spawnFirework();
  }
  // update fireworks
  for(let k=fireworks.length-1;k>=0;k--){
    const fw = fireworks[k];
    for(let j=fw.parts.length-1;j>=0;j--){
      let part = fw.parts[j];
      part.vx *= 0.985;
      part.vy *= 0.985;
      part.vy += 0.04; // gravity small
      part.x += part.vx;
      part.y += part.vy;
      part.age++;
      const a = Math.max(0,1 - part.age/part.life);
      ctx.beginPath();
      ctx.fillStyle = `rgba(${part.color.r},${part.color.g},${part.color.b},${a})`;
      ctx.arc(part.x,part.y,part.size*(a+0.2),0,Math.PI*2);
      ctx.fill();
      if(part.age>part.life) fw.parts.splice(j,1);
    }
    if(fw.parts.length===0) fireworks.splice(k,1);
  }

  // big glow
  drawBigHeartGlow();

  // draw an abstract big heart outline using parametric curve for emphasis
  ctx.save();
  ctx.translate(W/2, H*0.45);
  ctx.scale(Math.min(W,H)/50, Math.min(W,H)/50);
  ctx.lineWidth = 0.9;
  ctx.beginPath();
  for(let tt=0; tt<=Math.PI*2; tt+=0.04){
    const hp = heartPoint(tt);
    const x = hp.x;
    const y = -hp.y;
    if(tt===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.closePath();
  const strokeGrad = ctx.createLinearGradient(-30,-30,30,30);
  strokeGrad.addColorStop(0,'rgba(255,180,210,0.9)');
  strokeGrad.addColorStop(1,'rgba(255,80,140,0.9)');
  ctx.strokeStyle = strokeGrad;
  ctx.globalCompositeOperation = 'lighter';
  ctx.stroke();
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();

  // orbiting tilted text
  txtAngle += 0.004;
  drawTextOnEllipse();

  // small particle sparkles around bottom
  for(let i=0;i<8;i++){
    const px = W/2 + Math.sin((t+i*10)/60)*220 + Math.cos(i*3.2)*20;
    const py = H*0.75 + Math.cos((t+i*5)/40)*6;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,215,235,0.06)';
    ctx.arc(px,py,Math.random()*2+0.6,0,Math.PI*2);
    ctx.fill();
  }

  requestAnimationFrame(step);
}
requestAnimationFrame(step);

// allow saving via data URL (user asked for file ready; this is extra)
</script>
</body>
</html>
